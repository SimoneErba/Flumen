/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ConnectionInput
 */
export interface ConnectionInput {
    /**
     * 
     * @type {string}
     * @memberof ConnectionInput
     */
    'location1Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionInput
     */
    'location2Id'?: string;
}
/**
 * 
 * @export
 * @interface ConnectionResponse
 */
export interface ConnectionResponse {
    /**
     * 
     * @type {string}
     * @memberof ConnectionResponse
     */
    'sourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionResponse
     */
    'targetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionResponse
     */
    'direction'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ConnectionResponse
     */
    'properties'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface CreateConnection
 */
export interface CreateConnection {
    /**
     * 
     * @type {string}
     * @memberof CreateConnection
     */
    'itemId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnection
     */
    'locationId'?: string;
}
/**
 * 
 * @export
 * @interface GraphData
 */
export interface GraphData {
    /**
     * 
     * @type {Array<LocationResponse>}
     * @memberof GraphData
     */
    'locations'?: Array<LocationResponse>;
    /**
     * 
     * @type {Array<ConnectionResponse>}
     * @memberof GraphData
     */
    'connections'?: Array<ConnectionResponse>;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'speed'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Item
     */
    'active'?: boolean;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Item
     */
    'properties'?: { [key: string]: object; };
    /**
     * 
     * @type {Location}
     * @memberof Item
     */
    'location'?: Location;
    /**
     * 
     * @type {ProgressInfo}
     * @memberof Item
     */
    'progressInfo'?: ProgressInfo;
}
/**
 * 
 * @export
 * @interface ItemInput
 */
export interface ItemInput {
    /**
     * 
     * @type {string}
     * @memberof ItemInput
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemInput
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemInput
     */
    'speed'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemInput
     */
    'active'?: boolean;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ItemInput
     */
    'properties'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ItemResponse
 */
export interface ItemResponse {
    /**
     * 
     * @type {string}
     * @memberof ItemResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemResponse
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemResponse
     */
    'speed'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ItemResponse
     */
    'properties'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'length'?: number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'speed'?: number;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    'active'?: boolean;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Location
     */
    'properties'?: { [key: string]: object; };
    /**
     * 
     * @type {Set<string>}
     * @memberof Location
     */
    'outboundConnectionIds'?: Set<string>;
}
/**
 * 
 * @export
 * @interface LocationInput
 */
export interface LocationInput {
    /**
     * 
     * @type {string}
     * @memberof LocationInput
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationInput
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof LocationInput
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationInput
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationInput
     */
    'length'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationInput
     */
    'speed'?: number;
    /**
     * 
     * @type {string}
     * @memberof LocationInput
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LocationInput
     */
    'active'?: boolean;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof LocationInput
     */
    'properties'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface LocationResponse
 */
export interface LocationResponse {
    /**
     * 
     * @type {string}
     * @memberof LocationResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationResponse
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof LocationResponse
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationResponse
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationResponse
     */
    'length'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationResponse
     */
    'speed'?: number;
    /**
     * 
     * @type {string}
     * @memberof LocationResponse
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LocationResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof LocationResponse
     */
    'properties'?: { [key: string]: object; };
    /**
     * 
     * @type {Array<ItemResponse>}
     * @memberof LocationResponse
     */
    'items'?: Array<ItemResponse>;
    /**
     * 
     * @type {Array<ConnectionResponse>}
     * @memberof LocationResponse
     */
    'connections'?: Array<ConnectionResponse>;
}
/**
 * 
 * @export
 * @interface ProgressInfo
 */
export interface ProgressInfo {
    /**
     * 
     * @type {number}
     * @memberof ProgressInfo
     */
    'progress'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProgressInfo
     */
    'datetime'?: string;
}
/**
 * 
 * @export
 * @interface UpdateModel
 */
export interface UpdateModel {
    /**
     * 
     * @type {string}
     * @memberof UpdateModel
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof UpdateModel
     */
    'properties'?: { [key: string]: object; };
}

/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current state of the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the current state of the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraphData(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGraphData(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphApi.getGraphData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the current state of the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphData(options?: RawAxiosRequestConfig): AxiosPromise<GraphData> {
            return localVarFp.getGraphData(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI {
    /**
     * 
     * @summary Get the current state of the graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getGraphData(options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).getGraphData(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemControllerApi - axios parameter creator
 * @export
 */
export const ItemControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ItemInput} itemInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem: async (itemInput: ItemInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemInput' is not null or undefined
            assertParamExists('createItem', 'itemInput', itemInput)
            const localVarPath = `/api/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItem', 'id', id)
            const localVarPath = `/api/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemById', 'id', id)
            const localVarPath = `/api/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateModel} updateModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (updateModel: UpdateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateModel' is not null or undefined
            assertParamExists('updateItem', 'updateModel', updateModel)
            const localVarPath = `/api/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemControllerApi - functional programming interface
 * @export
 */
export const ItemControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ItemInput} itemInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItem(itemInput: ItemInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItem(itemInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemControllerApi.createItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemControllerApi.deleteItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemControllerApi.getAllItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemControllerApi.getItemById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateModel} updateModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(updateModel: UpdateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItem(updateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemControllerApi.updateItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemControllerApi - factory interface
 * @export
 */
export const ItemControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ItemInput} itemInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(itemInput: ItemInput, options?: RawAxiosRequestConfig): AxiosPromise<Item> {
            return localVarFp.createItem(itemInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItems(options?: RawAxiosRequestConfig): AxiosPromise<Array<Item>> {
            return localVarFp.getAllItems(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Item> {
            return localVarFp.getItemById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateModel} updateModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(updateModel: UpdateModel, options?: RawAxiosRequestConfig): AxiosPromise<Item> {
            return localVarFp.updateItem(updateModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemControllerApi - object-oriented interface
 * @export
 * @class ItemControllerApi
 * @extends {BaseAPI}
 */
export class ItemControllerApi extends BaseAPI {
    /**
     * 
     * @param {ItemInput} itemInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public createItem(itemInput: ItemInput, options?: RawAxiosRequestConfig) {
        return ItemControllerApiFp(this.configuration).createItem(itemInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public deleteItem(id: string, options?: RawAxiosRequestConfig) {
        return ItemControllerApiFp(this.configuration).deleteItem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public getAllItems(options?: RawAxiosRequestConfig) {
        return ItemControllerApiFp(this.configuration).getAllItems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public getItemById(id: string, options?: RawAxiosRequestConfig) {
        return ItemControllerApiFp(this.configuration).getItemById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateModel} updateModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public updateItem(updateModel: UpdateModel, options?: RawAxiosRequestConfig) {
        return ItemControllerApiFp(this.configuration).updateItem(updateModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationConnectionControllerApi - axios parameter creator
 * @export
 */
export const LocationConnectionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConnectionInput} connectionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection1: async (connectionInput: ConnectionInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionInput' is not null or undefined
            assertParamExists('createConnection1', 'connectionInput', connectionInput)
            const localVarPath = `/api/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sourceId 
         * @param {string} targetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection: async (sourceId: string, targetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteConnection', 'sourceId', sourceId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('deleteConnection', 'targetId', targetId)
            const localVarPath = `/api/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['targetId'] = targetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} locationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnections1: async (locationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('deleteConnections1', 'locationId', locationId)
            const localVarPath = `/api/connections/{locationId}`
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConnectionInput} connectionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveConnection1: async (connectionInput: ConnectionInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionInput' is not null or undefined
            assertParamExists('moveConnection1', 'connectionInput', connectionInput)
            const localVarPath = `/api/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationConnectionControllerApi - functional programming interface
 * @export
 */
export const LocationConnectionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationConnectionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConnectionInput} connectionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection1(connectionInput: ConnectionInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnection1(connectionInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationConnectionControllerApi.createConnection1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sourceId 
         * @param {string} targetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnection(sourceId: string, targetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnection(sourceId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationConnectionControllerApi.deleteConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} locationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnections1(locationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnections1(locationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationConnectionControllerApi.deleteConnections1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ConnectionInput} connectionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveConnection1(connectionInput: ConnectionInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveConnection1(connectionInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationConnectionControllerApi.moveConnection1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationConnectionControllerApi - factory interface
 * @export
 */
export const LocationConnectionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationConnectionControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ConnectionInput} connectionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection1(connectionInput: ConnectionInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createConnection1(connectionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sourceId 
         * @param {string} targetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(sourceId: string, targetId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteConnection(sourceId, targetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} locationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnections1(locationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteConnections1(locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConnectionInput} connectionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveConnection1(connectionInput: ConnectionInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.moveConnection1(connectionInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationConnectionControllerApi - object-oriented interface
 * @export
 * @class LocationConnectionControllerApi
 * @extends {BaseAPI}
 */
export class LocationConnectionControllerApi extends BaseAPI {
    /**
     * 
     * @param {ConnectionInput} connectionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationConnectionControllerApi
     */
    public createConnection1(connectionInput: ConnectionInput, options?: RawAxiosRequestConfig) {
        return LocationConnectionControllerApiFp(this.configuration).createConnection1(connectionInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sourceId 
     * @param {string} targetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationConnectionControllerApi
     */
    public deleteConnection(sourceId: string, targetId: string, options?: RawAxiosRequestConfig) {
        return LocationConnectionControllerApiFp(this.configuration).deleteConnection(sourceId, targetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} locationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationConnectionControllerApi
     */
    public deleteConnections1(locationId: string, options?: RawAxiosRequestConfig) {
        return LocationConnectionControllerApiFp(this.configuration).deleteConnections1(locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConnectionInput} connectionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationConnectionControllerApi
     */
    public moveConnection1(connectionInput: ConnectionInput, options?: RawAxiosRequestConfig) {
        return LocationConnectionControllerApiFp(this.configuration).moveConnection1(connectionInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationControllerApi - axios parameter creator
 * @export
 */
export const LocationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LocationInput} locationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLocation: async (locationInput: LocationInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationInput' is not null or undefined
            assertParamExists('createLocation', 'locationInput', locationInput)
            const localVarPath = `/api/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLocation', 'id', id)
            const localVarPath = `/api/locations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLocations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLocationById', 'id', id)
            const localVarPath = `/api/locations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateModel} updateModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLocation: async (updateModel: UpdateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateModel' is not null or undefined
            assertParamExists('updateLocation', 'updateModel', updateModel)
            const localVarPath = `/api/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationControllerApi - functional programming interface
 * @export
 */
export const LocationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LocationInput} locationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLocation(locationInput: LocationInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLocation(locationInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationControllerApi.createLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLocation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLocation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationControllerApi.deleteLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllLocations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Location>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllLocations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationControllerApi.getAllLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocationById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocationById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationControllerApi.getLocationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateModel} updateModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLocation(updateModel: UpdateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLocation(updateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationControllerApi.updateLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationControllerApi - factory interface
 * @export
 */
export const LocationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {LocationInput} locationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLocation(locationInput: LocationInput, options?: RawAxiosRequestConfig): AxiosPromise<Location> {
            return localVarFp.createLocation(locationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteLocation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLocations(options?: RawAxiosRequestConfig): AxiosPromise<Array<Location>> {
            return localVarFp.getAllLocations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Location> {
            return localVarFp.getLocationById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateModel} updateModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLocation(updateModel: UpdateModel, options?: RawAxiosRequestConfig): AxiosPromise<Location> {
            return localVarFp.updateLocation(updateModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationControllerApi - object-oriented interface
 * @export
 * @class LocationControllerApi
 * @extends {BaseAPI}
 */
export class LocationControllerApi extends BaseAPI {
    /**
     * 
     * @param {LocationInput} locationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationControllerApi
     */
    public createLocation(locationInput: LocationInput, options?: RawAxiosRequestConfig) {
        return LocationControllerApiFp(this.configuration).createLocation(locationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationControllerApi
     */
    public deleteLocation(id: string, options?: RawAxiosRequestConfig) {
        return LocationControllerApiFp(this.configuration).deleteLocation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationControllerApi
     */
    public getAllLocations(options?: RawAxiosRequestConfig) {
        return LocationControllerApiFp(this.configuration).getAllLocations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationControllerApi
     */
    public getLocationById(id: string, options?: RawAxiosRequestConfig) {
        return LocationControllerApiFp(this.configuration).getLocationById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateModel} updateModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationControllerApi
     */
    public updateLocation(updateModel: UpdateModel, options?: RawAxiosRequestConfig) {
        return LocationControllerApiFp(this.configuration).updateLocation(updateModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PositionsApi - axios parameter creator
 * @export
 */
export const PositionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new position connection
         * @param {CreateConnection} createConnection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (createConnection: CreateConnection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createConnection' is not null or undefined
            assertParamExists('createConnection', 'createConnection', createConnection)
            const localVarPath = `/api/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConnection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete position connections for an item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnections: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteConnections', 'itemId', itemId)
            const localVarPath = `/api/positions/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move an item to a new position
         * @param {CreateConnection} createConnection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveConnection: async (createConnection: CreateConnection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createConnection' is not null or undefined
            assertParamExists('moveConnection', 'createConnection', createConnection)
            const localVarPath = `/api/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConnection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PositionsApi - functional programming interface
 * @export
 */
export const PositionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PositionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new position connection
         * @param {CreateConnection} createConnection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(createConnection: CreateConnection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnection(createConnection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionsApi.createConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete position connections for an item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnections(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnections(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionsApi.deleteConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move an item to a new position
         * @param {CreateConnection} createConnection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveConnection(createConnection: CreateConnection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveConnection(createConnection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionsApi.moveConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PositionsApi - factory interface
 * @export
 */
export const PositionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PositionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new position connection
         * @param {CreateConnection} createConnection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(createConnection: CreateConnection, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createConnection(createConnection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete position connections for an item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnections(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteConnections(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move an item to a new position
         * @param {CreateConnection} createConnection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveConnection(createConnection: CreateConnection, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.moveConnection(createConnection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PositionsApi - object-oriented interface
 * @export
 * @class PositionsApi
 * @extends {BaseAPI}
 */
export class PositionsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new position connection
     * @param {CreateConnection} createConnection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    public createConnection(createConnection: CreateConnection, options?: RawAxiosRequestConfig) {
        return PositionsApiFp(this.configuration).createConnection(createConnection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete position connections for an item
     * @param {string} itemId ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    public deleteConnections(itemId: string, options?: RawAxiosRequestConfig) {
        return PositionsApiFp(this.configuration).deleteConnections(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move an item to a new position
     * @param {CreateConnection} createConnection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    public moveConnection(createConnection: CreateConnection, options?: RawAxiosRequestConfig) {
        return PositionsApiFp(this.configuration).moveConnection(createConnection, options).then((request) => request(this.axios, this.basePath));
    }
}



